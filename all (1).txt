# Selection Sort

#include<stdio.h>

void selsort(int [], int);

void main()
{
    int i,num;
    int arr[100],a[100];
    
    printf("Enter number of Elements: ");
    scanf("%d",&num);
    
    printf("Enter the Elements: ");
    for(i=0;i<num;i++)
    {
        scanf("%d",&arr[i]);
    }
    printf("The Elements of the array Before Sorting: \n");
    for(i=0;i<num;i++)
    {
        printf("%d\n",arr[i]);
    }
    
    
    selsort(arr,num);
    printf("The Elements of the array After Sorting: \n");
    for(i=0;i<num;i++)
    {
        printf("%d\n",arr[i]);
    }
    
}

void selsort(int arr[], int num)
{
    int i,m,min,temp,a[100];
    for(i=0;i<num-1;i++)
    {
        min=i;
        for(int j=i+1;j<num;j++)
        {
            if(arr[j]<arr[min])
            {
                min=j;
            }
        }
    
        if(min!=i)
        {
            temp = arr[i];
            arr[i] = arr[min];
            arr[min] = temp;
        }
    }   
}


# Insertion Sort

#include<stdio.h>

void insertionsort(int [], int);

void main()
{
    int i,num;
    int arr[100],a[100];
    
    printf("Enter number of Elements: ");
    scanf("%d",&num);
    
    printf("Enter the Elements: ");
    for(i=0;i<num;i++)
    {
        scanf("%d",&arr[i]);
    }
    printf("The Elements of the array Before Sorting: \n");
    for(i=0;i<num;i++)
    {
        printf("%d\n",arr[i]);
    }
    
    
    insertionsort(arr,num);
    printf("The Elements of the array After Sorting: \n");
    for(i=0;i<num;i++)
    {
        printf("%d\n",arr[i]);
    }
    
}

void insertionsort(int arr[], int num)
{
    int temp,j;
    for(int i=0;i<num;i++)
    {
        temp=arr[i];
        j=i-1;
        while(j>=0 && arr[j]>temp)
        {
            arr[j+1]=arr[j];
            j--;
        }
        arr[j+1]=temp;
    }
}


# Merge Sort

#include<stdio.h>

int main()
{
    
    int n;
    int arr[100];
    
    printf("Enter number of elements: ");
    scanf("%d",&n);
    
    printf("Enter the elements to be sorted: ");
    for(int i=0;i<n;i++)
    {
        scanf("%d",&arr[i]);
    }

    printf("The Sortted Array is: \n");
    for (int i = 0; i < n; i++)
    {
        printf("%d\n ", arr[i]);
    }

    mergesort(arr,0,n-1);
    
    
    printf("The Sortted Array is: \n");
    for (int i = 0; i < n; i++)
    {
        printf("%d\n", arr[i]);
    }
    
    return 0;
    
}

void merge(int arr[], int mid , int low, int high)
{
    int i,j,k,b[100],n;
    i=low;
    j=mid+1;
    k=low;
    
    while(i<=mid && j<=high)
    {
        if(arr[i]<arr[j])
        {
            b[k]=arr[i];
            i++;
            k++;
            
        }
        else
        {
            b[k]=arr[j];
            j++;
            k++;
        }
    }
        while(i<=mid)
        {
            b[k]=arr[i];
            k++;
            i++; 
        }
        while(j<=high)
        {
            b[k]=arr[j];
            k++;
            j++; 
        }
        
        for(i=low;i<=high;i++)
        {
            arr[i]=b[i];
        }
}

void mergesort(int arr[], int low, int high)
{
    int mid;
    if(low<high)
    {
        mid = (low+high)/2;
        mergesort(arr,low,mid);
        mergesort(arr,mid+1,high);
        merge(arr,mid,low,high);
        
    }
}



# Quick Sort

#include<stdio.h>

int main()
{
    int i,n;
    int arr[100];
    
    printf("Enter the number of Elements: \n");
    scanf("%d",&n);
    
    printf("Enter the Elements: \n");
    for(i=0;i<n;i++)
    {
        scanf("%d",&arr[i]);
    }
    
    printf("Array before sorting: \n");
    for(i=0;i<n;i++)
    {
        printf("%d ",arr[i]);
    }
    printf("\n");
    
    quicksort(arr,0,n-1);
    
    printf("Array After sorting: \n");
    for(i=0;i<n;i++)
    {
        printf("%d ",arr[i]);
    }
    
    return 0;
    
}

void quicksort(int arr[], int low, int high)
{
    if(low<high){
        int partitionindex;
        
        partitionindex = partition(arr, low, high);
        quicksort(arr, low, partitionindex-1);
        quicksort(arr, partitionindex+1, high);
    }
}

int partition(int arr[], int low, int high)
{
    int temp;
    int pivot=arr[low];
    int i = low+1;
    int j = high;
    
    do
    {
        while(arr[i]<=pivot)
        {
            i++;
        }
        while(arr[j]>pivot)
        {
            j--;
        }
        if(i<j)
        {
            temp=arr[i];
            arr[i]=arr[j];
            arr[j]=temp;
        }
    }
    while(i<j);
    
    temp=arr[low];
    arr[low]=arr[j];
    arr[j]=temp;
    
    return j;
}


# Binary Search


#include<stdio.h>

void main()
{
    int i,n,result,search;
    int arr[100];
    
    printf("Enter the number of elements: ");
    scanf("%d",&n);
    
    printf("Enter the elements: ");
    for(i=0;i<n;i++)
    {
        scanf("%d",&arr[i]);
    }
    
    printf("Enter the element to be searched: ");
    scanf("%d",&search);
    
    result = binarysearch(arr,n,search);
    
    printf("The element %d is found at location %d ", search, result);
}

int binarysearch(int arr[], int n, int search)
{
    int low,mid,high;
    low = 0;
    high = n-1;
    
    while(low<=high)
    {
        mid = (low+high)/2;
        if(arr[mid] == search)
        {
            return mid;
        }
        if(arr[mid] < search)
        {
            low = mid + 1;
        }
        if(arr[mid] > search)
        {
            high = mid - 1;
        }
    }
    
    return -1;
}


# Naive String

// C program for Naive Pattern Searching algorithm
#include <stdio.h>
#include <string.h>
 
void search(char* pat, char* txt)
{
    int M = strlen(pat);
    int N = strlen(txt);
 
    
    for (int i = 0; i <= N - M; i++) 
    {
        int j;
 
        for (j = 0; j < M; j++)
            if (txt[i + j] != pat[j])
                break;
 
        if (j == M) 
        printf("Pattern found at index %d \n", i);
    }
}
 
int main()
{
    char txt[] = "ATHARVA";
    char pat[] = "TH";
   
   //print text
    int i;
    printf("The Entered Text String is: ");
    for(i=0;i<=7;i++)
    {
        printf("%c ",txt[i]);
    }
    printf("\n");
    
    //print pattern
    printf("The Entered Pattern String is: ");
    for(i=0;i<=2;i++)
    {
        printf("%c ",pat[i]);
    }
    printf("\n");
    
    search(pat, txt);
    return 0;
} 


# LCS

#include<stdio.h>
#include<string.h>

int i,j,m,n,lcs[20][20],b[20][20];
char s1[20]="ACADBEF";
char s2[20]="CBDAE";

void lcsalgo(){
 m = strlen(s1);
 n = strlen(s2);

//adding zero's to the diagonal elements

for(i=0;i<=m;i++)
lcs[i][0] = 0;
for(i=0;i<=n;i++)
lcs[0][i] = 0;

//building the matrix the bottom-up way

for(i=1;i<=m;i++)
    for(j=1;j<=n;j++)
    {
        if(s1[i-1] == s2[j-1])
        {
            lcs[i][j] = lcs[i-1][j-1]+1;
        }
        else if(lcs[i-1][j] >= lcs[i][j-1])
        {
            lcs[i][j] = lcs[i-1][j];
        }
        else
        {
            lcs[i][j] = lcs[i][j-1];
        }
    }
    
    int index = lcs[m][n];
    char lcsalgo[index + 1];
    lcsalgo[index]='\0';
    
    int i=m,j=n;
    while(i>0 && j>0)
    {
        if(s1[i-1] == s2[j-1])
        {
            lcsalgo[index-1] = s1[i-1];
            i--;
            j--;
            index--;
        }
        else if(lcs[i-1][j] > lcs[i][j-1])
        {
            i--;
        }
        else
        {
            j--;
        }
    }
    
    
     printf("S1: %s\n",s1);
        printf("S2: %s\n",s2);
        printf("LCS: %s\n", lcsalgo);


}

int main()
{
    lcsalgo();
    printf("\n");
    
}


####bell ford

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

struct Edge

{
    int source, destination, weight;
};

struct Graph
{
    int V, E;
    struct Edge *edge;
};
struct Graph *createGraph(int V, int E)
{
    struct Graph *graph = (struct Graph *)malloc(
        sizeof(struct Graph));
    graph->V = V;
    graph->E = E;
    graph->edge = (struct Edge *)malloc(graph->E * sizeof(struct Edge));
    return graph;
}

void FinalSolution(int dist[], int n)
{
    printf("\nVertex\tDistance from Source Vertex\n");
    int i;
    for (i = 0; i < n; ++i)
    {
        printf("%d \t\t %d\n", i, dist[i]);
    }
}

void BellmanFord(struct Graph *graph, int source)
{
    int V = graph->V;
    int E = graph->E;
    int StoreDistance[V];
    int i, j;
    for (i = 0; i < V; i++)
        StoreDistance[i] = INT_MAX;
    StoreDistance[source] = 0;
    for (i = 1; i <= V - 1; i++)
    {
        for (j = 0; j < E; j++)
        {
            int u = graph->edge[j].source;
            int v = graph->edge[j].destination;
            int weight = graph->edge[j].weight;
            if (StoreDistance[u] + weight < StoreDistance[v])
                StoreDistance[v] = StoreDistance[u] + weight;
        }
    }
    for (i = 0; i < E; i++)
    {
        int u = graph->edge[i].source;
        int v = graph->edge[i].destination;
        int weight = graph->edge[i].weight;
        if (StoreDistance[u] + weight < StoreDistance[v])
            printf("This graph contains negative edge cycle\n");
    }
    FinalSolution(StoreDistance, V);
    return;
}

int main()
{
    int V, E, S;
    printf("Enter number of vertices in graph\n");
    scanf("%d", &V);
    printf("Enter number of edges in graph\n");
    scanf("%d", &E);
    printf("Enter your source vertex number\n");
    scanf("%d", &S);
    struct Graph *graph = createGraph(V, E);
    int i;
    for (i = 0; i < E; i++)
    {
        printf("\nEnter edge %d properties Source, destination,weight respectively\n", i + 1);
        scanf("%d", &graph->edge[i].source);
        scanf("%d", &graph->edge[i].destination);
        scanf("%d", &graph->edge[i].weight);
    }

    BellmanFord(graph, S);
    return 0;
}
# kapsack

# include<stdio.h>
void knapsack(int n, float weight[], float profit[], float capacity) {
float x[20], tp = 0;
int i, j, u;
u = capacity;
for (i = 0; i< n; i++)
x[i] = 0.0;
for (i = 0; i< n; i++) {
if (weight[i] > u)
break;
else {
x[i] = 1.0;
tp = tp + profit[i];
u = u - weight[i];
}
}
if (i< n)
x[i] = u / weight[i];
tp = tp + (x[i] * profit[i]);
printf("\nThe result is: ");
for (i = 0; i< n; i++)
printf("%f\t", x[i]);
printf("\nMaximum profit is: %f", tp);
}
int main() {
float weight[20], profit[20], capacity;
int num, i, j;
float ratio[20], temp;
printf("\nEnter the no. of objects: ");
scanf("%d", &num);
printf("\nEnter the weght and profit for each object: ");
for (i = 0; i<num; i++) {
scanf("%f %f", &weight[i], &profit[i]);
}
printf("\nEnter the capacity of knapsack: ");
scanf("%f", &capacity);
for (i = 0; i<num; i++) {
ratio[i] = profit[i] / weight[i];
}
for (i = 0; i<num; i++) {
for (j = i + 1; j <num; j++) {
if (ratio[i] < ratio[j]) {
temp = ratio[j];
ratio[j] = ratio[i];
ratio[i] = temp;
temp = weight[j];
weight[j] = weight[i];
weight[i] = temp;
temp = profit[j];
profit[j] = profit[i];
profit[i] = temp;
}
}
}
knapsack(num, weight, profit, capacity);
return(0);
}

##queens
#include<stdio.h>
#include<math.h>
#include<stdlib.h>
int board[20],count;
int main()
{
int n,i,j;
void queen(int row,int n);
printf("\n\nEnter number of Queens:");
scanf("%d",&n);
queen(1,n);
return 0;
}

void print(int n)
{
int i,j;
printf("\n\nSolution %d:\n\n",++count);
for(i=1;i<=n;++i)
printf("\t%d",i);
for(i=1;i<=n;++i)
{
printf("\n\n%d",i);
for(j=1;j<=n;++j) 
 {
if(board[i]==j)
printf("\tQ"); 
else
printf("\t-");
 }
}
}

int place(int row,int column)
{
int i;
for(i=1;i<=row-1;++i)
{
if(board[i]==column)
return 0;
else
if(abs(board[i]-column)==abs(i-row))
return 0;
}
return 1; 
}

void queen(int row,int n)
{
int column;
for(column=1;column<=n;++column)
{
if(place(row,column))
 {
board[row]=column; 
if(row==n) 
print(n); 
else 
queen(row+1,n);
 }
}
}


#tsp
#include<stdio.h> 
int a[10][10],visited[10],n,cost=0; 
void get()
{
int i,j;
printf("Enter No. of Cities: "); 
scanf("%d",&n); 
printf("\nEnter Cost Matrix\n"); 
for(i=0;i <n;i++) {
printf("\nEnter Elements of Row # : %d\n",i+1); 
for( j=0;j <n;j++) 
scanf("%d",&a[i][j]);
visited[i]=0;
}
printf("\n\nThe cost list is:\n\n");
for(i=0;i <n;i++)
{
printf("\n\n"); 
for(j=0;j <n;j++)
printf("\t%d",a[i][j]);
}
}
void mincost(int city)
{
int i,ncity; 
visited[city]=1; 
printf("%d -->",city+1);
ncity=least(city); 
if(ncity==999) 
{ 
    ncity=0; 
    printf("%d",ncity+1);
    cost+=a[city][ncity]; 
    return; 
    
} 
mincost(ncity);
}
int least(int c)
{
int i,nc=999; 
int min=999,kmin; 
for(i=0;i <n;i++) 
{
if((a[c][i]!=0)&&(visited[i]==0))
if(a[c][i] < min) 
{ 
    min=a[i][0]+a[c][i]; 
    kmin=a[c][i]; nc=i; 
    
} 
    
}
if(min!=999) 
cost+=kmin; 
return nc; 
    
} 

void put() 
{
printf("\n\nMinimum cost:");
printf("%d",cost); 
    
} 
void main()
{
get();
printf("\n\nThe Path is:\n\n");
mincost(0);
put(); 
    
}

